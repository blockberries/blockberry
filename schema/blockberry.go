// Code generated by cramberry. DO NOT EDIT.
// Source: /Volumes/Tendermint/stealth/blockberry/blockberry.cram

package blockberry

import (
	"github.com/blockberries/cramberry/pkg/cramberry"
)

type HelloRequest struct {
	NodeId       *string `cramberry:"1,required" json:"node_id"`
	Version      *int32  `cramberry:"2,required" json:"version"`
	InboundUrl   string  `cramberry:"3" json:"inbound_url"`
	InboundPort  int32   `cramberry:"4" json:"inbound_port"`
	ChainId      *string `cramberry:"5,required" json:"chain_id"`
	Timestamp    *int64  `cramberry:"6,required" json:"timestamp"`
	LatestHeight *int64  `cramberry:"7,required" json:"latest_height"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *HelloRequest) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *HelloRequest) encodeTo(w *cramberry.Writer) {
	if m.NodeId != nil {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.NodeId)
	}
	if m.Version != nil {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt32(*m.Version)
	}
	if m.InboundUrl != "" {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteString(m.InboundUrl)
	}
	if m.InboundPort != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.InboundPort)
	}
	if m.ChainId != nil {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.ChainId)
	}
	if m.Timestamp != nil {
		w.WriteCompactTag(6, cramberry.WireTypeV2SVarint)
		w.WriteInt64(*m.Timestamp)
	}
	if m.LatestHeight != nil {
		w.WriteCompactTag(7, cramberry.WireTypeV2SVarint)
		w.WriteInt64(*m.LatestHeight)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *HelloRequest) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *HelloRequest) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			var tmp string
			tmp = r.ReadString()
			m.NodeId = &tmp
		case 2:
			var tmp int32
			tmp = r.ReadInt32()
			m.Version = &tmp
		case 3:
			m.InboundUrl = r.ReadString()
		case 4:
			m.InboundPort = r.ReadInt32()
		case 5:
			var tmp string
			tmp = r.ReadString()
			m.ChainId = &tmp
		case 6:
			var tmp int64
			tmp = r.ReadInt64()
			m.Timestamp = &tmp
		case 7:
			var tmp int64
			tmp = r.ReadInt64()
			m.LatestHeight = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *HelloRequest) Validate() error {
	// Field node_id is required
	if m.NodeId == nil {
		return cramberry.NewValidationError("HelloRequest", "node_id", "required field is missing")
	}
	// Field version is required
	if m.Version == nil {
		return cramberry.NewValidationError("HelloRequest", "version", "required field is missing")
	}
	// Field chain_id is required
	if m.ChainId == nil {
		return cramberry.NewValidationError("HelloRequest", "chain_id", "required field is missing")
	}
	// Field timestamp is required
	if m.Timestamp == nil {
		return cramberry.NewValidationError("HelloRequest", "timestamp", "required field is missing")
	}
	// Field latest_height is required
	if m.LatestHeight == nil {
		return cramberry.NewValidationError("HelloRequest", "latest_height", "required field is missing")
	}
	return nil
}

type HelloResponse struct {
	Accepted  *bool  `cramberry:"1,required" json:"accepted"`
	PublicKey []byte `cramberry:"2" json:"public_key"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *HelloResponse) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *HelloResponse) encodeTo(w *cramberry.Writer) {
	if m.Accepted != nil {
		w.WriteCompactTag(1, cramberry.WireTypeV2Varint)
		w.WriteBool(*m.Accepted)
	}
	if len(m.PublicKey) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.PublicKey)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *HelloResponse) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *HelloResponse) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			var tmp bool
			tmp = r.ReadBool()
			m.Accepted = &tmp
		case 2:
			m.PublicKey = r.ReadBytes()
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *HelloResponse) Validate() error {
	// Field accepted is required
	if m.Accepted == nil {
		return cramberry.NewValidationError("HelloResponse", "accepted", "required field is missing")
	}
	return nil
}

type HelloFinalize struct {
	Success *bool `cramberry:"1,required" json:"success"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *HelloFinalize) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *HelloFinalize) encodeTo(w *cramberry.Writer) {
	if m.Success != nil {
		w.WriteCompactTag(1, cramberry.WireTypeV2Varint)
		w.WriteBool(*m.Success)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *HelloFinalize) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *HelloFinalize) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			var tmp bool
			tmp = r.ReadBool()
			m.Success = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *HelloFinalize) Validate() error {
	// Field success is required
	if m.Success == nil {
		return cramberry.NewValidationError("HelloFinalize", "success", "required field is missing")
	}
	return nil
}

type AddressRequest struct {
	LastSeen *int64 `cramberry:"1,required" json:"last_seen"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *AddressRequest) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *AddressRequest) encodeTo(w *cramberry.Writer) {
	if m.LastSeen != nil {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(*m.LastSeen)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *AddressRequest) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *AddressRequest) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			var tmp int64
			tmp = r.ReadInt64()
			m.LastSeen = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *AddressRequest) Validate() error {
	// Field last_seen is required
	if m.LastSeen == nil {
		return cramberry.NewValidationError("AddressRequest", "last_seen", "required field is missing")
	}
	return nil
}

type AddressInfo struct {
	Multiaddr *string `cramberry:"1,required" json:"multiaddr"`
	LastSeen  *int64  `cramberry:"2,required" json:"last_seen"`
	Latency   *int32  `cramberry:"3,required" json:"latency"`
	NodeId    *string `cramberry:"4,required" json:"node_id"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *AddressInfo) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *AddressInfo) encodeTo(w *cramberry.Writer) {
	if m.Multiaddr != nil {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.Multiaddr)
	}
	if m.LastSeen != nil {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt64(*m.LastSeen)
	}
	if m.Latency != nil {
		w.WriteCompactTag(3, cramberry.WireTypeV2SVarint)
		w.WriteInt32(*m.Latency)
	}
	if m.NodeId != nil {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.NodeId)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *AddressInfo) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *AddressInfo) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			var tmp string
			tmp = r.ReadString()
			m.Multiaddr = &tmp
		case 2:
			var tmp int64
			tmp = r.ReadInt64()
			m.LastSeen = &tmp
		case 3:
			var tmp int32
			tmp = r.ReadInt32()
			m.Latency = &tmp
		case 4:
			var tmp string
			tmp = r.ReadString()
			m.NodeId = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *AddressInfo) Validate() error {
	// Field multiaddr is required
	if m.Multiaddr == nil {
		return cramberry.NewValidationError("AddressInfo", "multiaddr", "required field is missing")
	}
	// Field last_seen is required
	if m.LastSeen == nil {
		return cramberry.NewValidationError("AddressInfo", "last_seen", "required field is missing")
	}
	// Field latency is required
	if m.Latency == nil {
		return cramberry.NewValidationError("AddressInfo", "latency", "required field is missing")
	}
	// Field node_id is required
	if m.NodeId == nil {
		return cramberry.NewValidationError("AddressInfo", "node_id", "required field is missing")
	}
	return nil
}

type AddressResponse struct {
	Peers []AddressInfo `cramberry:"1" json:"peers"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *AddressResponse) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *AddressResponse) encodeTo(w *cramberry.Writer) {
	if len(m.Peers) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Peers)))
		for _, v := range m.Peers {
			v.encodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *AddressResponse) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *AddressResponse) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			n := int(r.ReadUvarint())
			m.Peers = make([]AddressInfo, n)
			for i := 0; i < n; i++ {
				m.Peers[i].decodeFrom(r)
			}
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

type TransactionsRequest struct {
	BatchSize *int32 `cramberry:"1,required" json:"batch_size"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TransactionsRequest) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *TransactionsRequest) encodeTo(w *cramberry.Writer) {
	if m.BatchSize != nil {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt32(*m.BatchSize)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TransactionsRequest) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *TransactionsRequest) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			var tmp int32
			tmp = r.ReadInt32()
			m.BatchSize = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *TransactionsRequest) Validate() error {
	// Field batch_size is required
	if m.BatchSize == nil {
		return cramberry.NewValidationError("TransactionsRequest", "batch_size", "required field is missing")
	}
	return nil
}

type TransactionHash struct {
	Hash []byte `cramberry:"1,required" json:"hash"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TransactionHash) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *TransactionHash) encodeTo(w *cramberry.Writer) {
	if len(m.Hash) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Hash)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TransactionHash) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *TransactionHash) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Hash = r.ReadBytes()
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *TransactionHash) Validate() error {
	// Field hash is required
	if m.Hash == nil {
		return cramberry.NewValidationError("TransactionHash", "hash", "required field is missing")
	}
	return nil
}

type TransactionsResponse struct {
	Transactions []TransactionHash `cramberry:"1" json:"transactions"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TransactionsResponse) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *TransactionsResponse) encodeTo(w *cramberry.Writer) {
	if len(m.Transactions) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Transactions)))
		for _, v := range m.Transactions {
			v.encodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TransactionsResponse) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *TransactionsResponse) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			n := int(r.ReadUvarint())
			m.Transactions = make([]TransactionHash, n)
			for i := 0; i < n; i++ {
				m.Transactions[i].decodeFrom(r)
			}
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

type TransactionDataRequest struct {
	Transactions []TransactionHash `cramberry:"1" json:"transactions"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TransactionDataRequest) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *TransactionDataRequest) encodeTo(w *cramberry.Writer) {
	if len(m.Transactions) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Transactions)))
		for _, v := range m.Transactions {
			v.encodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TransactionDataRequest) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *TransactionDataRequest) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			n := int(r.ReadUvarint())
			m.Transactions = make([]TransactionHash, n)
			for i := 0; i < n; i++ {
				m.Transactions[i].decodeFrom(r)
			}
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

type TransactionData struct {
	Hash []byte `cramberry:"1,required" json:"hash"`
	Data []byte `cramberry:"2,required" json:"data"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TransactionData) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *TransactionData) encodeTo(w *cramberry.Writer) {
	if len(m.Hash) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Hash)
	}
	if len(m.Data) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Data)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TransactionData) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *TransactionData) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Hash = r.ReadBytes()
		case 2:
			m.Data = r.ReadBytes()
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *TransactionData) Validate() error {
	// Field hash is required
	if m.Hash == nil {
		return cramberry.NewValidationError("TransactionData", "hash", "required field is missing")
	}
	// Field data is required
	if m.Data == nil {
		return cramberry.NewValidationError("TransactionData", "data", "required field is missing")
	}
	return nil
}

type TransactionDataResponse struct {
	Transactions []TransactionData `cramberry:"1" json:"transactions"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TransactionDataResponse) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *TransactionDataResponse) encodeTo(w *cramberry.Writer) {
	if len(m.Transactions) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Transactions)))
		for _, v := range m.Transactions {
			v.encodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TransactionDataResponse) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *TransactionDataResponse) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			n := int(r.ReadUvarint())
			m.Transactions = make([]TransactionData, n)
			for i := 0; i < n; i++ {
				m.Transactions[i].decodeFrom(r)
			}
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

type BlocksRequest struct {
	BatchSize *int32 `cramberry:"1,required" json:"batch_size"`
	Since     *int64 `cramberry:"2,required" json:"since"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BlocksRequest) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *BlocksRequest) encodeTo(w *cramberry.Writer) {
	if m.BatchSize != nil {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt32(*m.BatchSize)
	}
	if m.Since != nil {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt64(*m.Since)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BlocksRequest) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *BlocksRequest) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			var tmp int32
			tmp = r.ReadInt32()
			m.BatchSize = &tmp
		case 2:
			var tmp int64
			tmp = r.ReadInt64()
			m.Since = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *BlocksRequest) Validate() error {
	// Field batch_size is required
	if m.BatchSize == nil {
		return cramberry.NewValidationError("BlocksRequest", "batch_size", "required field is missing")
	}
	// Field since is required
	if m.Since == nil {
		return cramberry.NewValidationError("BlocksRequest", "since", "required field is missing")
	}
	return nil
}

type BlockData struct {
	Height *int64 `cramberry:"1,required" json:"height"`
	Hash   []byte `cramberry:"2,required" json:"hash"`
	Data   []byte `cramberry:"3,required" json:"data"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BlockData) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *BlockData) encodeTo(w *cramberry.Writer) {
	if m.Height != nil {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(*m.Height)
	}
	if len(m.Hash) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Hash)
	}
	if len(m.Data) > 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Data)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BlockData) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *BlockData) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			var tmp int64
			tmp = r.ReadInt64()
			m.Height = &tmp
		case 2:
			m.Hash = r.ReadBytes()
		case 3:
			m.Data = r.ReadBytes()
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *BlockData) Validate() error {
	// Field height is required
	if m.Height == nil {
		return cramberry.NewValidationError("BlockData", "height", "required field is missing")
	}
	// Field hash is required
	if m.Hash == nil {
		return cramberry.NewValidationError("BlockData", "hash", "required field is missing")
	}
	// Field data is required
	if m.Data == nil {
		return cramberry.NewValidationError("BlockData", "data", "required field is missing")
	}
	return nil
}

type BlocksResponse struct {
	Blocks []BlockData `cramberry:"1" json:"blocks"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BlocksResponse) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *BlocksResponse) encodeTo(w *cramberry.Writer) {
	if len(m.Blocks) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Blocks)))
		for _, v := range m.Blocks {
			v.encodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BlocksResponse) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *BlocksResponse) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			n := int(r.ReadUvarint())
			m.Blocks = make([]BlockData, n)
			for i := 0; i < n; i++ {
				m.Blocks[i].decodeFrom(r)
			}
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

type LatencyRequest struct {
	Timestamp *int64 `cramberry:"1,required" json:"timestamp"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *LatencyRequest) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *LatencyRequest) encodeTo(w *cramberry.Writer) {
	if m.Timestamp != nil {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(*m.Timestamp)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *LatencyRequest) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *LatencyRequest) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			var tmp int64
			tmp = r.ReadInt64()
			m.Timestamp = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *LatencyRequest) Validate() error {
	// Field timestamp is required
	if m.Timestamp == nil {
		return cramberry.NewValidationError("LatencyRequest", "timestamp", "required field is missing")
	}
	return nil
}

type LatencyResponse struct {
	Latency *int64 `cramberry:"1,required" json:"latency"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *LatencyResponse) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *LatencyResponse) encodeTo(w *cramberry.Writer) {
	if m.Latency != nil {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(*m.Latency)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *LatencyResponse) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *LatencyResponse) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			var tmp int64
			tmp = r.ReadInt64()
			m.Latency = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *LatencyResponse) Validate() error {
	// Field latency is required
	if m.Latency == nil {
		return cramberry.NewValidationError("LatencyResponse", "latency", "required field is missing")
	}
	return nil
}

type FirewallRequest struct {
	Endpoint *string `cramberry:"1,required" json:"endpoint"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *FirewallRequest) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *FirewallRequest) encodeTo(w *cramberry.Writer) {
	if m.Endpoint != nil {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.Endpoint)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *FirewallRequest) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *FirewallRequest) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			var tmp string
			tmp = r.ReadString()
			m.Endpoint = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *FirewallRequest) Validate() error {
	// Field endpoint is required
	if m.Endpoint == nil {
		return cramberry.NewValidationError("FirewallRequest", "endpoint", "required field is missing")
	}
	return nil
}

type FirewallResponse struct {
	Endpoint *string `cramberry:"1,required" json:"endpoint"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *FirewallResponse) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.encodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// encodeTo encodes the message directly to the writer using V2 format.
func (m *FirewallResponse) encodeTo(w *cramberry.Writer) {
	if m.Endpoint != nil {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(*m.Endpoint)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *FirewallResponse) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.decodeFrom(r)
	return r.Err()
}

// decodeFrom decodes the message from the reader using V2 format.
func (m *FirewallResponse) decodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, _ := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			var tmp string
			tmp = r.ReadString()
			m.Endpoint = &tmp
		default:
			// Skip unknown field - read wire type would have been needed
			// For now, just break as we can't determine how to skip
			break
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *FirewallResponse) Validate() error {
	// Field endpoint is required
	if m.Endpoint == nil {
		return cramberry.NewValidationError("FirewallResponse", "endpoint", "required field is missing")
	}
	return nil
}

// HandshakeMessage is a polymorphic interface.
type HandshakeMessage interface {
	isHandshakeMessage()
}

func (*HelloRequest) isHandshakeMessage() {}

func (*HelloResponse) isHandshakeMessage() {}

func (*HelloFinalize) isHandshakeMessage() {}

// HandshakeMessageTypeID returns the type ID for interface implementations.
func HandshakeMessageTypeID(v HandshakeMessage) cramberry.TypeID {
	switch v.(type) {
	case *HelloRequest:
		return 128
	case *HelloResponse:
		return 129
	case *HelloFinalize:
		return 130
	default:
		return 0
	}
}

// PexMessage is a polymorphic interface.
type PexMessage interface {
	isPexMessage()
}

func (*AddressRequest) isPexMessage() {}

func (*AddressResponse) isPexMessage() {}

// PexMessageTypeID returns the type ID for interface implementations.
func PexMessageTypeID(v PexMessage) cramberry.TypeID {
	switch v.(type) {
	case *AddressRequest:
		return 131
	case *AddressResponse:
		return 132
	default:
		return 0
	}
}

// TransactionsMessage is a polymorphic interface.
type TransactionsMessage interface {
	isTransactionsMessage()
}

func (*TransactionsRequest) isTransactionsMessage() {}

func (*TransactionsResponse) isTransactionsMessage() {}

func (*TransactionDataRequest) isTransactionsMessage() {}

func (*TransactionDataResponse) isTransactionsMessage() {}

// TransactionsMessageTypeID returns the type ID for interface implementations.
func TransactionsMessageTypeID(v TransactionsMessage) cramberry.TypeID {
	switch v.(type) {
	case *TransactionsRequest:
		return 133
	case *TransactionsResponse:
		return 134
	case *TransactionDataRequest:
		return 135
	case *TransactionDataResponse:
		return 136
	default:
		return 0
	}
}

// BlockSyncMessage is a polymorphic interface.
type BlockSyncMessage interface {
	isBlockSyncMessage()
}

func (*BlocksRequest) isBlockSyncMessage() {}

func (*BlocksResponse) isBlockSyncMessage() {}

// BlockSyncMessageTypeID returns the type ID for interface implementations.
func BlockSyncMessageTypeID(v BlockSyncMessage) cramberry.TypeID {
	switch v.(type) {
	case *BlocksRequest:
		return 137
	case *BlocksResponse:
		return 138
	default:
		return 0
	}
}

// BlockMessage is a polymorphic interface.
type BlockMessage interface {
	isBlockMessage()
}

func (*BlockData) isBlockMessage() {}

// BlockMessageTypeID returns the type ID for interface implementations.
func BlockMessageTypeID(v BlockMessage) cramberry.TypeID {
	switch v.(type) {
	case *BlockData:
		return 139
	default:
		return 0
	}
}

// HousekeepingMessages is a polymorphic interface.
type HousekeepingMessages interface {
	isHousekeepingMessages()
}

func (*LatencyRequest) isHousekeepingMessages() {}

func (*LatencyResponse) isHousekeepingMessages() {}

func (*FirewallRequest) isHousekeepingMessages() {}

func (*FirewallResponse) isHousekeepingMessages() {}

// HousekeepingMessagesTypeID returns the type ID for interface implementations.
func HousekeepingMessagesTypeID(v HousekeepingMessages) cramberry.TypeID {
	switch v.(type) {
	case *LatencyRequest:
		return 140
	case *LatencyResponse:
		return 141
	case *FirewallRequest:
		return 142
	case *FirewallResponse:
		return 143
	default:
		return 0
	}
}
